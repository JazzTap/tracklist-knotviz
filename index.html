<head>
    <script src="./lib/aframe.min.js"></script>
    <script src="./lib/aframe-forcegraph-component.min.js"></script>
    <!-- <script src="./lib/aframe-extras.min.js"></script> -->
    <script src="./lib/aframe-orbit-controls.min.js"></script>
    
    <!-- fixme: font polyfills don't land in time for texture init -->
    <style>
        @font-face {
            font-family: Roboto Condensed;
            src: url('./lib/RobotoCondensed-Regular.ttf'), url('./lib/RobotoCondensed-Bold.ttf');
        }
        @font-face {
            font-family: Roboto;
            src: url('./lib/Roboto-Regular.ttf'), url('./lib/Roboto-Bold.ttf');
        }
    </style>
    <script>

    lyricsResponse = undefined
    fetch('./gen/lyrics-dict.json').then((re) => {lyricsResponse = re.json()})
    // FIXME: doubtful that loader & callbacks outside of aframe component are kosher.

    songQuery = ''
    window.addEventListener('keydown', (e) => {
        // todo: with scroll listener, fix 'screenspace' text for orbitcontrols camera
        // document.querySelector('a-entity[camera]')
        
        if ('abcdefghijklmnopqrstuvwxyz'.includes(e.key))
            console.log(songQuery += e.key)
        else if (e.key == 'Backspace')
            console.log(songQuery = songQuery.slice(0, -1))
        else if (e.key == 'Enter')
            console.log(songQuery = '')
        
        lyricsResponse.then((ldict) => {
            ldict.forEach(d => {
                let i = d.id
                if (!innerMats[i] || !outerMats[i])
                    return // guard against lyrics with no node
                    
                if (songQuery.length == 0) {
                    innerMats[i].color.setHex(unfocus)
                    outerMats[i].color.setHex(unfocus)
                }
                else {
                    innerMats[i].color.setHex( d.song.toLowerCase().includes(songQuery) ? colors[i] : unfocus)
                    outerMats[i].color.setHex( d.artist.toLowerCase().includes(songQuery) ? colors[i] : unfocus)
                }
            })
        })
    });
    
    // TODO: highlight by song query. outline by artist, fill by song.
    innerMats = []
    outerMats = []
    selectorSphere = function(u) {
        colors[u.id] = colorMap(u)
        
        let geometry = new THREE.SphereGeometry( u.weight * .25, 32, 32 ),
            material = new THREE.MeshLambertMaterial( {color: unfocus,
                                                       transparent: true, opacity: 0.8} ),
            outline = new THREE.MeshBasicMaterial( {color: unfocus, side: THREE.BackSide,
                                                    transparent: true, opacity: 0.8})
        
        innerMats[u.id] = material // FIXME: extend the forcegraph instead of just sinking my pointers in, kudzu-like
        outerMats[u.id] = outline
        
        let res = new THREE.Mesh( geometry, outline ),
            ret = new THREE.Group()
        res.scale.multiplyScalar(1.1) // https://stemkoski.github.io/Three.js/Outline.html
        
        ret.add(new THREE.Mesh( geometry, material ))
        ret.add(res)
        return ret;
    }
    
    colors = []
    unfocus = 0xaaaaaa
    colorMap = function(u) {
        let h = parseInt(u.year) - 1985, b = 70
        if (isNaN(h)) {h = 0; b = 100} // fallback
        h *= 8
        
        let s = 'hsl(' + [h, '90%', b + '%'].join(',') + ')'
        return new THREE.Color(s).getHex()
    }

    // lyrics in 3d scene
    ltexW = 128; ltexH = 512
    textMaterial = function(u) {
        let canvas = document.createElement('canvas'),
            cv = canvas.getContext('2d')
        canvas.width = ltexW; canvas.height = ltexH
        
        let ret = new THREE.MeshLambertMaterial({
            map: new THREE.Texture(canvas),
            transparent: true,
            opacity: 0.7,
            depthWrite: false,
        });
        u.mat = ret // for use outside this closure
        u.canvas = canvas
        u.flip = false

        printLyrics(cv, u)
        return ret
    }

    printLyrics = function (cv, link) {
        // todo: argument i in range(0, ldict[u.source.id].lyrics.length)
        // if (link.fake) return // fake links each get their own invisible texture

        cv.setTransform(1,0,0,1,0,0)
        cv.clearRect(0,0, ltexW,ltexH)
        
        cv.fillStyle = 'black'
        cv.globalAlpha = .2
        cv.fillRect(0,0, ltexW,ltexH)
        
        cv.font = 'Bold 20px Roboto Condensed' // FIXME: wait for font to load
        cv.fillStyle = 'white'
        cv.globalAlpha = 1
        // cv.textAlign = 'center'

        lyricsResponse.then((ldict) => {
            // let v = lyrics.find(v => v.id == u.source.id) // not assuming sort
            let u = link.flip ? ldict[link.target.id] : ldict[link.source.id],
                v = link.flip ? ldict[link.source.id] : ldict[link.target.id]
            
            let i = Math.floor(Math.random() * (u.lyrics.length - 3)),
                j = Math.floor(Math.random() * (v.lyrics.length - 3))
            let set = [].concat( // fails gracefully for '[instrumental]'
                    u.lyrics.slice(i, i+3),
                    v.lyrics.slice(j, j+3)
                    )
            link.lyrics = set // save for blotting
            
            cv.translate(ltexW/2, ltexH/2)
            cv.rotate(-Math.PI/2)
            set.forEach((s,k) => {
                let x = -ltexW/2, y = -48 + 20*k
                // cv.fillText(s, 0, y)
                
                s.split(' ').forEach(w => {
                    if (w == 'Instrumental')
                        cv.fillText(k < 3 ? u.song : v.song, x, y); // BRITTLE to 'set'
                    else {
                        cv.fillStyle =
                            ['go', 'bring', 'through', 'away', 'inside', 'travel', 'world', 'dreams', 'keep', 'carry', 'turn', 'hidden', 'place', 'down', 'among', 'transition']
                            .includes(w.toLowerCase()) ? 'aquamarine' : 
                            // sight
                            ['time', 'ending', 'strike', 'suddenly', 'born', 'moon', 'now', 'never', 'fade', 'survive', 'obsolete', 'disappear', 'vanished', 'seconds', 'slows']
                            .includes(w.toLowerCase()) ? 'salmon' :
                            // speech
                            'white';
                        cv.fillText(w, x, y);
                        x += cv.measureText(w + ' ').width; // https://stackoverflow.com/a/7665485
                    }
                })
            })
            
            link.mat.map.needsUpdate = true
            link.flip = !link.flip
            
            // yes, Promise resolution can monkey-patch returned Material
            // ret.color = new THREE.Color(u.source.id/150, 0, u.target.id/150)
        })
    }
    
    // lyrics to console
    let scroll = {}
    blotLyrics = function(u, u_) {
        if (u_) u_.mat.opacity = 0.7
        if (u) u.mat.opacity = 1
        
        if (u && !u_) { // (initial) enter
        }

        if (u_) { // exit
            let v = u_,
                cv = v.canvas.getContext('2d')
            printLyrics(cv, v)
            if (!v.lyrics) return

            let i = scroll[v.source.song]
            if (i === undefined)
                scroll[v.source.song] = i = Math.floor(Math.random() * v.lyrics.length)
            if (i >= v.lyrics.length)
                scroll[v.source.song] = i = 0
            
            let odds = (s) => 9 / (10 + s.length)
            
            let k = 0, ret = []
            while (k < 2 && i+k < v.lyrics.length) {
                let s = v.lyrics[i+k].split(' '),
                    res = s.map(w => Math.random() < odds(s) ? w : '').join(' ')
                        // '_'.repeat(w.length) // prefer to not preserve length info

                if (res != 'Instrumental') {
                    console.log(res)
                    ret.push(res)
                }
                else console.log()
                k += 1
            }            
            scroll[v.source.song] += k
        }        
        // scratch - in vr space...
        // cv.requestAnimationFrame()
        // mat.map.needsUpdate = true
    }
    </script>
</head>
<body>
    <a-scene states=false keyboard-shortcuts="enterVR: false">
    <a-entity camera look-controls orbit-controls="target: 0 1.6 0; minDistance: 15; maxDistance: 580; keyPanSpeed: 50; zoomSpeed: 2.5; initialPosition: 0 5 15"> </a-entity>
        <a-sky color="#222"></a-sky>

    <a-entity id="graph" forcegraph="json-url: gen/thumbprint-graph.json; node-label: song; node-desc: artist; node-three-object: selectorSphere; link-width: 10; link-material: textMaterial; link-resolution: 32; on-link-center-hover: blotLyrics; warmup-ticks: 100; cooldown-ticks: 50000;"></a-entity>
        <!-- node-val: weight; node-rel-size: 4; node-opacity: .75;  -->
    </a-scene>
</body>